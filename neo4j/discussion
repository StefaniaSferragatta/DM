CYPHER - NEO4J EXPLENATION

In the first part of the hws we have used a Relational database in which the data were store in tables with a fixed 
structure, the schema. To query the db we had to use join on the keyes to reach information form a table to another.
In this last part we choose Neo4j as NoSQL dbms that is based on graph.
Even if the schema of our database was already normalized, we had to process it a little bit more in order to translate it
into an equivalent graph model. In this transformation, the rows of entity tables are converted into nodes 
and the foreign-key relationships into relationships. 
Basically each table became a node whose properties are the columns of the table.

The language used to query the Graph db in Neo4j is Cypher that unlike SQL, is all about expressing graph patterns. 


QUERIES EXPLENATION


// query 1 
// Return all gene names together with the number of drugs associated
match (g)-[:alteration]->(d)
return g.name, count(distinct d) as num_drugs

// Return all gene names together with the number of sample in which are overexpressed
match (g)-[:is_overexpressed]->(s)
return g.name, count(distinct s) as num_samples

// query 2
// Return the gene name given the name of a drug
MATCH (g:Gene)-[:alteration]->(p:Drug)
WHERE p.name STARTS WITH "Po" OR p.name CONTAINS 'nib'
return distinct g.name;

// query 3
// Return the top 5 genes per number of drugs associated 
match (g)-[:alteration]->(d)
with count(*) AS num_drug, g
return g.name, num_drug
order by num_drug desc
limit 5

// query 4
// Given a drug name, return the saple treated with it
MATCH (node1:Gene)-[:is_overexpressed]->(node2:Sample)
WHERE EXISTS ((node1)-[:alteration]->(:Drug {name: 'Ponatinib'}))
return node2.name as sample_id;

// PATH of query 4
MATCH path = ((node1:Gene)-[:is_overexpressed]->(node2:Sample))
WHERE EXISTS ((node1)-[:alteration]->(:Drug {name: 'Ponatinib'}))
return path

// query 5
MATCH path = ((d)<-[:alteration]-(g:Gene)-[:is_overexpressed]->(s))
WHERE d.name = 'Dabrafenib'
return path, g.name;

// query 6
// Given a sample, visualize the drugs associated to the oncogene genes
match (node2 {name: 'TCGA-B5-A5OE-01A-11R-A31O-07'})<-[:is_overexpressed]-(node1 {is_oncogene: '1'})-[:alteration]->(node3)
return node1,node2,node3

// query 7
// Find tumor suppressor genes that are overexpressed in at least 5 types of cancer
match (g:Gene {is_tumor_suppressor: '1'})-[:is_overexpressed]->(node2) 
with count(distinct node2.cancer) as num_cancer, g
where num_cancer > 5
return distinct(g.name) as gene_id, num_cancer

// query 8
// Given a sample ID, return a list of overexpressed gene and possible type of alterations
CALL {
    MATCH (node1:Gene)-[r:alteration]->(node2:Drug)
    return node1
    UNION
    MATCH (node1:Gene)-[:is_overexpressed]->(node2:Sample {name: 'TCGA-B5-A5OE-01A-11R-A31O-07'})
    return node1
}
WITH node1,[(node1)-[r: alteration]->(node2) |  r.name] AS alterations_name
UNWIND alterations_name as alt_name
RETURN node1.name as gene_id, collect(distinct alt_name)

The CALL() procedure is used for the subqueries. Here we combine the two queries with the UNION and we use the 
result of this to find the list of the alterations. The function UNWIND() is used to transform any list back into individual rows in order to take the distinct values using the
function COLLECT() that returns a single aggregated list containing the values.

// query 9
// Find the sample which has the greates number of associated drugs and its list
MATCH (b)<-[:is_overexpressed]-(a)-[:alteration]->(c)
RETURN b.name as sample_id, COLLECT(distinct c.name) as drugs
ORDER BY SIZE(drugs) DESC LIMIT 1

Also in this query we use the COLLECT() function to obtain the aggregated list containing the drugs name associated to that sample.
The size of the list is ordered in decrescent order and we pick the first one only that is the greates.

// query 10
// Visualize the sample and the related gene that is oncogene and whose alteration is 'Oncogenic Mutations'
CALL {
Match (g)-[:alteration {name : 'Oncogenic Mutations'}]->(:Drug)
return g
}
with g, (g {is_oncogene:'1'})-[:is_overexpressed]->(:Sample) as list_sample
UNWIND list_sample as sample
return distinct sample

// Add a relationship between the samples and the drugs given the cancer type and the gene
MATCH (d:Drug)--(g:Gene)--(s:Sample)
WHERE s.cancer = 'CHOL' AND g.name = 'ALK'
MERGE (s)-[r:treated_with]->(d)
RETURN s,d
